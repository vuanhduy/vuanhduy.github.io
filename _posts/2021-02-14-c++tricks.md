---
layout: post
title:  "C++ tricks"
date:   2021-02-14 10:56:33 -0400
categories: [C++ programming language]
tags: ["C++"]
toc: true
---

This note is a set of tips and tricks that I have learnt in coding with the C++ programming language.

## The RAII technique

[RAII]( https://en.cppreference.com/w/cpp/language/raii) stands for Resource Acquisition Is Initialization. It is officially defined as “a C++ programming technique which binds the life cycle of a resource that must be acquired before use to the lifetime of an object. RAII guarantees that the resource is available to any function that may access the object. It also guarantees that all resources are released when the lifetime of their controlling object ends.” This briefly means that we need to:

1.	Encapsulate each resource into a class: the constructor will acquire the resource, and the destructor releases the resource
1.	Use the resource via a **local instance** of the class (i.e., not a pointer or static variable)

Let look at the following example.

```C++
void notUseRAII() {
    char *msg = nullptr;
    int ret = mystery_function(&msg);   // msg is allocated by mystery_function (when success)
                                        // and must be manually freed latter
    if (ret != 0)       // there is an error and msg has not been allocated.
        return;

    // Do something ...

    delete msg;
}
```

Although function `notUseRAII` looks good, there is a potential memory leak. If an exception occurs while `Doing something`, then `delete` is not invoked. Thus, there will be a memory leak.

Now, let apply RAII by wrapping `msg` using a `struct`.

```C++
struct MsgWrapper {
    MsgWrapper() {
        status = mystery_function(&msg);
    }

    ~MsgWrapper() {
        if (msg != nullptr)
            delete msg;
    }

    char *msg = nullptr;
    int status;
};

void useRAII() {
    struct MsgWrapper wrapper;
    if (wrapper.status != 0)       // cannot get security context of the process
        return;

    // Do something ...
}
```

As `wrapper` is a **local variable**, its destructor is guaranteed to be invoked when leaving function `useRAII` for any reason. Thus, the memory of the `msg` is ensured to be deallocated.

